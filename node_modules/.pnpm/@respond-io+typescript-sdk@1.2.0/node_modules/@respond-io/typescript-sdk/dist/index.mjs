// src/client.ts
import axios, { AxiosError } from "axios";

// src/errors/index.ts
var RespondIOError = class _RespondIOError extends Error {
  constructor(statusCode, code, message, rateLimitInfo) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.rateLimitInfo = rateLimitInfo;
    this.name = "RespondIOError";
    Object.setPrototypeOf(this, _RespondIOError.prototype);
  }
  /**
   * Check if error is a rate limit error
   */
  isRateLimitError() {
    return this.statusCode === 429;
  }
  /**
   * Check if error is an authentication error
   */
  isAuthError() {
    return this.statusCode === 401;
  }
  /**
   * Check if error is a not found error
   */
  isNotFoundError() {
    return this.statusCode === 404;
  }
  /**
   * Check if error is a validation error
   */
  isValidationError() {
    return this.statusCode === 400;
  }
  /**
   * Check if error is a server error
   */
  isServerError() {
    return this.statusCode >= 500;
  }
  /**
   * Return a JSON representation of the error
   */
  toJSON() {
    return {
      statusCode: this.statusCode,
      code: this.code,
      message: this.message,
      rateLimitInfo: this.rateLimitInfo
    };
  }
};

// src/client.ts
var HTTPClient = class {
  axios;
  maxRetries;
  constructor(config) {
    this.axios = axios.create({
      baseURL: config.baseUrl || "https://api.respond.io/v2",
      headers: {
        Authorization: `Bearer ${config.apiToken}`,
        "Content-Type": "application/json"
      },
      timeout: config.timeout || 3e4
    });
    this.maxRetries = config.maxRetries || 3;
  }
  /**
   * Extract rate limit information from response headers
   */
  extractRateLimitInfo(response) {
    const limit = response.headers["x-ratelimit-limit"];
    const remaining = response.headers["x-ratelimit-remaining"];
    const retryAfter = response.headers["retry-after"];
    if (limit && remaining) {
      return {
        limit: parseInt(limit, 10),
        remaining: parseInt(remaining, 10),
        retryAfter: retryAfter ? parseInt(retryAfter, 10) : void 0
      };
    }
    return void 0;
  }
  /**
   * Handle API error responses
   */
  handleErrorResponse(error) {
    if (error.response) {
      const rateLimitInfo = this.extractRateLimitInfo(error.response);
      const { status, data } = error.response;
      throw new RespondIOError(status, data.code, data.message, rateLimitInfo);
    }
    throw new RespondIOError(0, 0, error.message);
  }
  /**
   * Execute an HTTP request with retry logic
   */
  async executeRequest(method, path, params, body, attempt = 1) {
    try {
      const response = await this.axios.request({
        method,
        url: path,
        params,
        data: body
      });
      return response.data;
    } catch (error) {
      if (error instanceof AxiosError) {
        if (error.response && (error.response.status === 429 || error.response.status >= 500) && attempt < this.maxRetries || !error.response && attempt < this.maxRetries) {
          const rateLimitInfo = error.response ? this.extractRateLimitInfo(error.response) : void 0;
          const delay = (rateLimitInfo == null ? void 0 : rateLimitInfo.retryAfter) ? rateLimitInfo.retryAfter * 1e3 : Math.min(1e3 * Math.pow(2, attempt), 1e4);
          await new Promise((resolve) => setTimeout(resolve, delay));
          return this.executeRequest(method, path, params, body, attempt + 1);
        }
        this.handleErrorResponse(error);
      }
      if (error instanceof Error) {
        throw new RespondIOError(0, 0, error.message);
      }
      throw new RespondIOError(0, 0, "Unknown error occurred");
    }
  }
  /**
   * Make a GET request
   */
  async get(path, params) {
    return this.executeRequest("get", path, params);
  }
  /**
   * Make a POST request
   */
  async post(path, body, params) {
    return this.executeRequest("post", path, params, body);
  }
  /**
   * Make a PUT request
   */
  async put(path, body) {
    return this.executeRequest("put", path, void 0, body);
  }
  /**
   * Make a DELETE request
   */
  async delete(path, body) {
    return this.executeRequest("delete", path, void 0, body);
  }
};

// src/clients/contact.ts
var ContactClient = class {
  constructor(http) {
    this.http = http;
  }
  /**
   * Get a contact by identifier
   * @param identifier - Contact identifier (id:123, email:user@example.com, phone:+1234567890)
   */
  async get(identifier) {
    return this.http.get(`/contact/${identifier}`);
  }
  /**
   * Create a new contact
   * @param identifier - Contact identifier (email:user@example.com or phone:+1234567890)
   * @param data - Contact data
   */
  async create(identifier, data) {
    return this.http.post(`/contact/${identifier}`, data);
  }
  /**
   * Update an existing contact
   * @param identifier - Contact identifier
   * @param data - Partial contact data to update
   */
  async update(identifier, data) {
    return this.http.put(`/contact/${identifier}`, data);
  }
  /**
   * Delete a contact
   * @param identifier - Contact identifier
   */
  async delete(identifier) {
    return this.http.delete(`/contact/${identifier}`);
  }
  /**
   * Create or update a contact
   * @param identifier - Contact identifier
   * @param data - Contact data
   */
  async createOrUpdate(identifier, data) {
    return this.http.post(`/contact/create_or_update/${identifier}`, data);
  }
  /**
   * Merge two contacts
   * @param request - Merge request with contact IDs and optional field updates
   */
  async merge(request) {
    return this.http.post("/contact/merge", request);
  }
  /**
   * List contacts with optional filters
   * @param filter - Filter criteria
   * @param pagination - Pagination parameters
   */
  async list(filter, pagination) {
    return this.http.post("/contact/list", filter, pagination);
  }
  /**
   * Add tags to a contact
   * @param identifier - Contact identifier
   * @param tags - Array of tag names (1-10 tags, max 255 chars each)
   */
  async addTags(identifier, tags) {
    return this.http.post(`/contact/${identifier}/tag`, tags);
  }
  /**
   * Remove tags from a contact
   * @param identifier - Contact identifier
   * @param tags - Array of tag names to remove
   */
  async deleteTags(identifier, tags) {
    return this.http.delete(`/contact/${identifier}/tag`, tags);
  }
  /**
   * List all channels connected to a contact
   * @param identifier - Contact identifier
   * @param pagination - Pagination parameters
   */
  async listChannels(identifier, pagination) {
    return this.http.get(`/contact/${identifier}/channels`, pagination);
  }
  /**
   * Update contact lifecycle stage
   * @param identifier - Contact identifier
   * @param request - Lifecycle update request (null to remove lifecycle)
   */
  async updateLifecycle(identifier, request) {
    return this.http.post(`/contact/${identifier}/lifecycle/update`, request);
  }
};

// src/clients/messaging.ts
var MessagingClient = class {
  constructor(http) {
    this.http = http;
  }
  /**
   * Send a message to a contact
   * @param identifier - Contact identifier
   * @param request - Message request
   */
  async send(identifier, request) {
    return this.http.post(`/contact/${identifier}/message`, request);
  }
  /**
   * Get a message by ID
   * @param identifier - Contact identifier
   * @param messageId - Message ID
   */
  async get(identifier, messageId) {
    return this.http.get(`/contact/${identifier}/message/${messageId}`);
  }
  /**
   * List messages for a contact
   * @param identifier - Contact identifier
   * @param pagination - Pagination parameters
   */
  async list(identifier, pagination) {
    return this.http.get(`/contact/${identifier}/message/list`, pagination);
  }
};

// src/clients/comment.ts
var CommentClient = class {
  constructor(http) {
    this.http = http;
  }
  /**
   * Create a comment on a contact
   * @param identifier - Contact identifier
   * @param request - Comment request
   */
  async create(identifier, request) {
    return this.http.post(`/contact/${identifier}/comment`, request);
  }
};

// src/clients/conversation.ts
var ConversationClient = class {
  constructor(http) {
    this.http = http;
  }
  /**
   * Assign or unassign a conversation
   * @param identifier - Contact identifier
   * @param request - Assignment request (null to unassign)
   */
  async assign(identifier, request) {
    return this.http.post(`/contact/${identifier}/conversation/assignee`, request);
  }
  /**
   * Open or close a conversation
   * @param identifier - Contact identifier
   * @param request - Status update request
   */
  async updateStatus(identifier, request) {
    return this.http.post(`/contact/${identifier}/conversation/status`, request);
  }
};

// src/clients/space.ts
var SpaceClient = class {
  constructor(http) {
    this.http = http;
  }
  /**
   * List users in the workspace
   * @param pagination - Pagination parameters
   */
  async listUsers(pagination) {
    return this.http.get("/space/user", pagination);
  }
  /**
   * Get a user by ID
   * @param id - User ID
   */
  async getUser(id) {
    return this.http.get(`/space/user/${id}`);
  }
  /**
   * Create a custom field
   * @param request - Custom field creation request
   */
  async createCustomField(request) {
    return this.http.post("/space/custom_field", request);
  }
  /**
   * List all custom fields
   * @param pagination - Pagination parameters
   */
  async listCustomFields(pagination) {
    return this.http.get("/space/custom_field", pagination);
  }
  /**
   * Get a custom field by ID
   * @param id - Custom field ID
   */
  async getCustomField(id) {
    return this.http.get(`/space/custom_field/${id}`);
  }
  /**
   * List closing notes
   * @param pagination - Pagination parameters
   */
  async listClosingNotes(pagination) {
    return this.http.get("/space/closing_notes", pagination);
  }
  /**
   * List all channels in the workspace
   * @param pagination - Pagination parameters
   */
  async listChannels(pagination) {
    return this.http.get("/space/channel", pagination);
  }
  /**
   * List message templates for a channel
   * @param channelId - Channel ID
   * @param pagination - Pagination parameters
   */
  async listTemplates(channelId, pagination) {
    return this.http.get(`/space/channel/${channelId}/template`, pagination);
  }
  /**
   * Create a workspace tag
   * @param request - Tag creation request
   */
  async createTag(request) {
    return this.http.post("/space/tag", request);
  }
  /**
   * Update a workspace tag
   * @param request - Tag update request
   */
  async updateTag(request) {
    return this.http.put("/space/tag", request);
  }
  /**
   * Delete a workspace tag
   * @param request - Tag deletion request
   */
  async deleteTag(request) {
    return this.http.delete("/space/tag", request);
  }
};

// src/index.ts
var RespondIO = class {
  http;
  /** Contact management operations */
  contacts;
  /** Messaging operations */
  messaging;
  /** Comment operations */
  comments;
  /** Conversation management operations */
  conversations;
  /** Workspace-level operations */
  space;
  /**
   * Create a new RespondIO SDK client
   * @param config - SDK configuration
   */
  constructor(config) {
    if (!config.apiToken) {
      throw new Error("API token is required");
    }
    this.http = new HTTPClient(config);
    this.contacts = new ContactClient(this.http);
    this.messaging = new MessagingClient(this.http);
    this.comments = new CommentClient(this.http);
    this.conversations = new ConversationClient(this.http);
    this.space = new SpaceClient(this.http);
  }
};
var index_default = RespondIO;
export {
  CommentClient,
  ContactClient,
  ConversationClient,
  HTTPClient,
  MessagingClient,
  RespondIO,
  RespondIOError,
  SpaceClient,
  index_default as default
};
